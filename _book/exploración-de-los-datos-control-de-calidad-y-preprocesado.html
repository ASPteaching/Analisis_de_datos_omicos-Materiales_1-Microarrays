<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Capítulo 3 {Exploración de los datos, control de calidad y preprocesado | Análisis de datos ómicos</title>
  <meta name="description" content="Capítulo 3 {Exploración de los datos, control de calidad y preprocesado | Análisis de datos ómicos" />
  <meta name="generator" content="bookdown 0.18 and GitBook 2.6.7" />

  <meta property="og:title" content="Capítulo 3 {Exploración de los datos, control de calidad y preprocesado | Análisis de datos ómicos" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Capítulo 3 {Exploración de los datos, control de calidad y preprocesado | Análisis de datos ómicos" />
  
  
  

<meta name="author" content="Alex Sánchez-Pla^{1,2} y Ricardo Gonzalo Sanz^2" />
<meta name="author" content="^1 Departament de Genètica, Microbiologia i Estadística. Universitat de Barcelona (UB)." />
<meta name="author" content="^2 Unitat d’Estadística i Bioinformàtica. Vall d’Hebron Institut de Recerca (VHIR)." />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="el-proceso-de-análisis-de-microarrays.html"/>
<link rel="next" href="referencias.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Presentación</a></li>
<li class="chapter" data-level="2" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html"><i class="fa fa-check"></i><b>2</b> El proceso de análisis de microarrays</a><ul>
<li class="chapter" data-level="2.1" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#tipos-de-estudios"><i class="fa fa-check"></i><b>2.1</b> Tipos de estudios</a><ul>
<li class="chapter" data-level="2.1.1" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#comparación-de-grupos-o-class-comparison"><i class="fa fa-check"></i><b>2.1.1</b> Comparación de grupos o <em>Class comparison</em></a></li>
<li class="chapter" data-level="2.1.2" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#predicción-de-clase-o-class-prediction"><i class="fa fa-check"></i><b>2.1.2</b> Predicción de clase o <em>Class prediction</em></a></li>
<li class="chapter" data-level="2.1.3" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#descubrimiento-de-clases-o-class-discovery"><i class="fa fa-check"></i><b>2.1.3</b> Descubrimiento de clases o <em>Class discovery</em></a></li>
<li class="chapter" data-level="2.1.4" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#otros-tipos-de-estudios"><i class="fa fa-check"></i><b>2.1.4</b> Otros tipos de estudios</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#algunos-ejemplos-concretos"><i class="fa fa-check"></i><b>2.2</b> Algunos ejemplos concretos </a><ul>
<li class="chapter" data-level="2.2.1" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#estudio-de-procesos-regulados-por-citoquinas"><i class="fa fa-check"></i><b>2.2.1</b> Estudio de procesos regulados por citoquinas </a></li>
<li class="chapter" data-level="2.2.2" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#clasificación-molecular-de-la-leucemialabelgolub"><i class="fa fa-check"></i><b>2.2.2</b> Clasificación molecular de la leucemia\label{golub]</a></li>
<li class="chapter" data-level="2.2.3" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#efecto-del-estrogeno-y-el-tiempo-de-administraciónlabelestrogen"><i class="fa fa-check"></i><b>2.2.3</b> Efecto del estrogeno y el tiempo de administración\label{estrogen]</a></li>
<li class="chapter" data-level="2.2.4" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#efecto-del-ccl4-en-la-expresión-génica"><i class="fa fa-check"></i><b>2.2.4</b> Efecto del CCL4 en la expresión génica</a></li>
<li class="chapter" data-level="2.2.5" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#análisis-de-patrones-en-el-ciclo-celular"><i class="fa fa-check"></i><b>2.2.5</b> Análisis de patrones en el ciclo celular</a></li>
<li class="chapter" data-level="2.2.6" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#recapitulación"><i class="fa fa-check"></i><b>2.2.6</b> Recapitulación</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="el-proceso-de-análisis-de-microarrays.html"><a href="el-proceso-de-análisis-de-microarrays.html#el-proceso-de-análisis-de-microarrays-1"><i class="fa fa-check"></i><b>2.3</b> El proceso de análisis de microarrays</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><i class="fa fa-check"></i><b>3</b> {Exploración de los datos, control de calidad y preprocesado</a><ul>
<li class="chapter" data-level="3.1" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#introducción"><i class="fa fa-check"></i><b>3.1</b> Introducción</a><ul>
<li class="chapter" data-level="3.1.1" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#nivel-de-análisis-y-tipo-de-microarray"><i class="fa fa-check"></i><b>3.1.1</b> Nivel de análisis y tipo de microarray</a></li>
<li class="chapter" data-level="3.1.2" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#datos-de-partida"><i class="fa fa-check"></i><b>3.1.2</b> Datos de partida</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#gráficos-para-la-exploración-y-control-de-calidad"><i class="fa fa-check"></i><b>3.2</b> Gráficos para la exploración y control de calidad</a><ul>
<li class="chapter" data-level="3.2.1" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#control-de-calidad-con-gráficos-estadísticos-generales"><i class="fa fa-check"></i><b>3.2.1</b> Control de calidad con gráficos estadísticos generales</a></li>
<li class="chapter" data-level="3.2.2" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#gráficos-de-diagnóstico-para-microarrays-de-dos-colores"><i class="fa fa-check"></i><b>3.2.2</b> Gráficos de diagnóstico para microarrays de dos colores</a></li>
<li class="chapter" data-level="3.2.3" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#gráficos-de-diagnóstico-para-microarrays-de-un-color"><i class="fa fa-check"></i><b>3.2.3</b> Gráficos de diagnóstico para microarrays de un color</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#normalización-de-arrays-de-dos-colores"><i class="fa fa-check"></i><b>3.3</b> Normalización de arrays de dos colores</a><ul>
<li class="chapter" data-level="3.3.1" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#normalización-global"><i class="fa fa-check"></i><b>3.3.1</b> Normalización global</a></li>
<li class="chapter" data-level="3.3.2" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#normalización-dependiente-de-la-intensidad"><i class="fa fa-check"></i><b>3.3.2</b> Normalización dependiente de la intensidad</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#resumen-y-normalización-de-microarrays-de-affymetrix"><i class="fa fa-check"></i><b>3.4</b> Resumen y normalización de microarrays de Affymetrix</a><ul>
<li class="chapter" data-level="3.4.1" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#métodos-originales-de-affymetrix"><i class="fa fa-check"></i><b>3.4.1</b> Métodos originales de Affymetrix</a></li>
<li class="chapter" data-level="3.4.2" data-path="exploración-de-los-datos-control-de-calidad-y-preprocesado.html"><a href="exploración-de-los-datos-control-de-calidad-y-preprocesado.html#el-método-rma-robust-multi-array-average"><i class="fa fa-check"></i><b>3.4.2</b> El método RMA (Robust Multi-Array Average)</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="referencias.html"><a href="referencias.html"><i class="fa fa-check"></i><b>4</b> Referencias</a></li>
<li class="chapter" data-level="5" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><i class="fa fa-check"></i><b>5</b> Apéndice: Conversión de archivos Latex a RMarkdown</a><ul>
<li class="chapter" data-level="5.1" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html#relación-de-cambios-imprescindibles"><i class="fa fa-check"></i><b>5.1</b> Relación de cambios imprescindibles</a><ul>
<li class="chapter" data-level="5.1.1" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html#títulos-y-subtítulos"><i class="fa fa-check"></i><b>5.1.1</b> Títulos y subtítulos</a></li>
<li class="chapter" data-level="5.1.2" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html#acentos"><i class="fa fa-check"></i><b>5.1.2</b> Acentos</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html#figuras"><i class="fa fa-check"></i><b>5.2</b> Figuras</a></li>
<li class="chapter" data-level="5.3" data-path="apéndice-conversión-de-archivos-latex-a-rmarkdown.html"><a href="apéndice-conversión-de-archivos-latex-a-rmarkdown.html#citaciones-y-referencias"><i class="fa fa-check"></i><b>5.3</b> Citaciones y referencias</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Análisis de datos ómicos</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="exploración-de-los-datos-control-de-calidad-y-preprocesado" class="section level1">
<h1><span class="header-section-number">Capítulo 3</span> {Exploración de los datos, control de calidad y preprocesado</h1>
<div id="introducción" class="section level2">
<h2><span class="header-section-number">3.1</span> Introducción</h2>
<p>Los estudios realizados con microarrays, sea cual sea la tecnología en que se basan, tienen una característica común: generan grandes cantidades de datos a través de una serie de procesos, que hacen que su significado no siempre sea completamente intuitivo.</p>
<p>Como en todo tipo de análisis, antes de empezar a trabajar con los datos, debemos de asegurarnos de que éstos son fiables y completos y de que se encuentran en la escala apropiada para proporcionar la información que pretendemos obtener de ellos.</p>
<p>En el caso de los microarrays solemos distinguir dos fases previas al análisis de los datos:</p>

<div id="nivel-de-análisis-y-tipo-de-microarray" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Nivel de análisis y tipo de microarray</h3>
Desde la generalización del uso de los microarrays se han
desarrollado muchas formas para visualizar los datos y decidir acerca
de su calidad. Algunas trabajan sobre los datos obtenidos del
escáner, otras lo hacen con los datos normalizados. Algunas sirven
tanto para arrays de dos colores como arrays de un color. Otras son
específicas de la tecnología. Con el fin de organizar esta
multitud de opciones podemos diferenciar:

<p>La exploración y el control de calidad pueden basarse en datos de bajo o de alto nivel. La tabla ~ muestra una clasificación de los distintos procedimientos según el tipo de datos y el tipo de microarray. Dichos procedimientos se explican en las secciones siguientes.</p>

</div>
<div id="datos-de-partida" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Datos de partida</h3>
<p>La estructura de los datos de microarrays de un color o de dos colores difiere considerablemente, tanto a nivel físico (los chips y las imágenes que de ellos se obtiene) como informático, es decir en la forma en que se representan.</p>
<div id="arrays-de-dos-colores-o-de-cdna" class="section level4">
<h4><span class="header-section-number">3.1.2.1</span> Arrays de dos colores (o de ``cDNA’’)</h4>
<p>Tradicionalmente los arrays de dos colores o de cDNA se realizaban de forma menos automatizada que los de un color o de Affymetrix.
Esto implica que, tras obtener la imagen, el escaneado del archivo <code>.TIFF'' \footnote{.TIFF es un formato para archivos de imagen de alta calidad} resultante puediera ser llevado a cabo mediante un \emph{software} independiente como \texttt{Genepix}. Este programa convierte las imágenes en números y genera un archivo de información (con extensión</code>.gpr’’) a partir del cual pueden
calcularse las expresiones relativas, así como valores de calidad para cada  o punto escaneado en la imagen.</p>
<p>Para cada imagen (o sea para cada microarray) hay un archivo .gpr que contiene una fila por gen y varias columnas con distintos valores, por ejemplo la intensidad para cada canal, valores resumen de las intensidades y controles de calidad (``FLAGS’’).</p>
<p>La tabla  muestra lo que serían las primeras filas y columnas de un archivo <code>.gpr'' obtenido mediante el programa</code>genepix’’.</p>

<p>Los valores de intensidad se convierten en una única  que contiene una columna por chip con los valores de intensidad relativa obtenidas por ejemplo con una ``sumarización’’ del tipo:
<span class="math display">\[
\log\frac{R-Rb}{G-Gb}
\]</span> y una fila por gen (mismas filas que archivos .gpr).</p>
<p>La tabla ~ muestra lo que sería una matriz de expresión derivada de cuatro archivos .gpr como los de la tabla .</p>
\begin{table}[htbp]

\texttt{

<p>}

\end{table}</p>
</div>
<div id="arrays-de-un-color-affymetrix" class="section level4">
<h4><span class="header-section-number">3.1.2.2</span> Arrays de un color (Affymetrix)</h4>
<p>El resultado de escanear la imagen de un array de affymetrix es un archivo de extensión
``.CEL’’ que, a diferencia de los arrays de dos colores, está en formato binario es decir que solo puede ser leído con programas específicos para ello.</p>
<p>De forma similar a los arrays de dos colores, existe un archivo .CEL por cada microarray chip, que contiene los valores PM () y MM () para cada sonda.</p>
<p>A partir de las intensidades de los archivos .CEL se genera la matriz de expresión que contiene una columna por chip con los valores de intensidad absoluta y una fila por grupo de sondas. En el caso de arrays de affymetrix existe una gran variedad de algoritmos de ``sumarización’’ y según cual se utilice se obtendrá unos u otros valores de expresión pero estos serán siempre medidas absolutas, es decir independientes del resto de muestras.</p>
<p>La tabla ~ muestra las primeras filas de una matriz de expresión sumarizada correspondiente a los primeros genes del caso resuelto 1.</p>
\begin{table}[htbp]

\texttt{

<p>}

\end{table}</p>
</div>
<div id="datos-de-ejemplo" class="section level4">
<h4><span class="header-section-number">3.1.2.3</span> Datos de ejemplo</h4>
Los ejemplos de este capítulo se basarán en dos de los conjuntos de datos descritos en el capítulo ~.


<pre><code>## Loading required package: BiocManager</code></pre>
<pre><code>## Warning: package &#39;BiocManager&#39; was built under R version 3.6.3</code></pre>
<pre><code>## Bioconductor version 3.9 (BiocManager 1.30.10), ?BiocManager::install for help</code></pre>
<pre><code>## Bioconductor version &#39;3.9&#39; is out-of-date; the current release version &#39;3.10&#39;
##   is available with R version &#39;3.6&#39;; see https://bioconductor.org/install</code></pre>
<pre><code>## Loading required package: CCl4</code></pre>
<pre><code>## Loading required package: Biobase</code></pre>
<pre><code>## Loading required package: BiocGenerics</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<pre><code>## 
## Attaching package: &#39;BiocGenerics&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:parallel&#39;:
## 
##     clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
##     clusterExport, clusterMap, parApply, parCapply, parLapply,
##     parLapplyLB, parRapply, parSapply, parSapplyLB</code></pre>
<pre><code>## The following objects are masked from &#39;package:stats&#39;:
## 
##     IQR, mad, sd, var, xtabs</code></pre>
<pre><code>## The following objects are masked from &#39;package:base&#39;:
## 
##     anyDuplicated, append, as.data.frame, basename, cbind, colnames,
##     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
##     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
##     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
##     union, unique, unsplit, which, which.max, which.min</code></pre>
<pre><code>## Welcome to Bioconductor
## 
##     Vignettes contain introductory material; view with
##     &#39;browseVignettes()&#39;. To cite Bioconductor, see
##     &#39;citation(&quot;Biobase&quot;)&#39;, and for packages &#39;citation(&quot;pkgname&quot;)&#39;.</code></pre>
<pre><code>## Loading required package: limma</code></pre>
<pre><code>## 
## Attaching package: &#39;limma&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:BiocGenerics&#39;:
## 
##     plotMA</code></pre>
<pre><code>## Loading required package: estrogen</code></pre>
<pre><code>## Loading required package: affy</code></pre>
</div>
</div>
</div>
<div id="gráficos-para-la-exploración-y-control-de-calidad" class="section level2">
<h2><span class="header-section-number">3.2</span> Gráficos para la exploración y control de calidad</h2>
<p>Los gráficos son útiles para comprobar la calidad de los datos de microarrays,
obtener información sobre cómo se deben preprocesar los datos y comprobar, finalmente, que el preprocesado se haya realizado correctamente.</p>
<p>Siguiendo el esquema presentado en la tabla  se presentan a continuación los distintos gráficos utilizados con una breve descripción de lo que representa cada uno y como interpretarlos adecuadamente. El código para generarlos se presenta al final del capítulo como un apéndice.</p>
<div id="control-de-calidad-con-gráficos-estadísticos-generales" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Control de calidad con gráficos estadísticos generales</h3>
<div id="histogramas-y-gráficos-de-densidad" class="section level4">
<h4><span class="header-section-number">3.2.1.1</span> Histogramas y gráficos de densidad</h4>
<p>Estos gráficos permite hacerse una idea de si las distribuciones de los distintos arrays son similares en forma y posición. La figura  muestra los histogramas correspondientes a los 9 arrays del conjunto de datos .</p>

</div>
<div id="diagramas-de-caja-o-boxplots" class="section level4">
<h4><span class="header-section-number">3.2.1.2</span> Diagramas de caja o ``boxplots’’</h4>
<p>Como los histogramas los diagramas de caja –basados en los distintos cuantiles de las valores– dan una idea de la distribución de las intensidades. La figura ~ muestra los diagramas de caja correspondientes a los 9 arrays del conjunto de datos .</p>

</div>
<div id="gráficos-de-componentes-principales" class="section level4">
<h4><span class="header-section-number">3.2.1.3</span> Gráficos de componentes principales</h4>
<p>El análisis de componentes principales puede servir para detectar si las muestras se agrupan de forma <code>natural'' es decir con otras muestras provenientes del mismo grupo o si no hay correspondencia clara entre grupos experimentales y proximidad en este gráfico. Cuando esto sucede no significa necesariamente que haya un problema pero puede ser indicativo de efectos técnicos --como el conocido efecto</code>batch’’– que podría ser necesario corregir.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" title="1">plotPCA &lt;-<span class="st"> </span><span class="cf">function</span> ( X, <span class="dt">labels=</span><span class="ot">NULL</span>, <span class="dt">colors=</span><span class="ot">NULL</span>, <span class="dt">dataDesc=</span><span class="st">&quot;&quot;</span>, <span class="dt">scale=</span><span class="ot">FALSE</span>)</a>
<a class="sourceLine" id="cb19-2" title="2">{</a>
<a class="sourceLine" id="cb19-3" title="3">  pcX&lt;-<span class="kw">prcomp</span>(<span class="kw">t</span>(X), <span class="dt">scale=</span>scale) <span class="co"># o prcomp(t(X))</span></a>
<a class="sourceLine" id="cb19-4" title="4">  loads&lt;-<span class="st"> </span><span class="kw">round</span>(pcX<span class="op">$</span>sdev<span class="op">^</span><span class="dv">2</span><span class="op">/</span><span class="kw">sum</span>(pcX<span class="op">$</span>sdev<span class="op">^</span><span class="dv">2</span>)<span class="op">*</span><span class="dv">100</span>,<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb19-5" title="5">  xlab&lt;-<span class="kw">c</span>(<span class="kw">paste</span>(<span class="st">&quot;PC1&quot;</span>,loads[<span class="dv">1</span>],<span class="st">&quot;%&quot;</span>))</a>
<a class="sourceLine" id="cb19-6" title="6">  ylab&lt;-<span class="kw">c</span>(<span class="kw">paste</span>(<span class="st">&quot;PC2&quot;</span>,loads[<span class="dv">2</span>],<span class="st">&quot;%&quot;</span>))</a>
<a class="sourceLine" id="cb19-7" title="7">  <span class="cf">if</span> (<span class="kw">is.null</span>(colors)) colors=<span class="dv">1</span></a>
<a class="sourceLine" id="cb19-8" title="8">  <span class="kw">plot</span>(pcX<span class="op">$</span>x[,<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],<span class="dt">xlab=</span>xlab,<span class="dt">ylab=</span>ylab, <span class="dt">col=</span>colors, </a>
<a class="sourceLine" id="cb19-9" title="9">       <span class="dt">xlim=</span><span class="kw">c</span>(<span class="kw">min</span>(pcX<span class="op">$</span>x[,<span class="dv">1</span>])<span class="op">-</span><span class="dv">10</span>, <span class="kw">max</span>(pcX<span class="op">$</span>x[,<span class="dv">1</span>])<span class="op">+</span><span class="dv">10</span>),</a>
<a class="sourceLine" id="cb19-10" title="10">       <span class="dt">ylim=</span><span class="kw">c</span>(<span class="kw">min</span>(pcX<span class="op">$</span>x[,<span class="dv">2</span>])<span class="op">-</span><span class="dv">10</span>, <span class="kw">max</span>(pcX<span class="op">$</span>x[,<span class="dv">2</span>])<span class="op">+</span><span class="dv">10</span>),</a>
<a class="sourceLine" id="cb19-11" title="11">       )</a>
<a class="sourceLine" id="cb19-12" title="12">  <span class="kw">text</span>(pcX<span class="op">$</span>x[,<span class="dv">1</span>],pcX<span class="op">$</span>x[,<span class="dv">2</span>], labels, <span class="dt">pos=</span><span class="dv">3</span>, <span class="dt">cex=</span><span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb19-13" title="13">  <span class="kw">title</span>(<span class="kw">paste</span>(<span class="st">&quot;Plot of first 2 PCs for expressions in&quot;</span>, dataDesc, <span class="dt">sep=</span><span class="st">&quot; &quot;</span>), <span class="dt">cex=</span><span class="fl">0.8</span>)</a>
<a class="sourceLine" id="cb19-14" title="14">}</a></code></pre></div>
<p>La figura ~ muestra dos diagramas de compnentes principales realizados a partir de los datos normalizados del conjunto de datos . El gráfico de la parte superior que incluye el array defectuoso ilustra que la principal fuente de variabilidad es la diferencia de este array con el resto. Cuando se repite el análisis omitiendo esta muestra puede verse como la principal fuente de variación (eje X) se asocia con el tiempo de exposición (alto a la derecha, bajo (10h) a la izquierda, mientras que la segunda fuente de variación se asocia con la exposición a los estrógenos (alto arriba, bajo abajo).</p>
<p>%El gráfico de la parte inferior en el que este array se ha eliminado antes de calcular las componentes principales muestra dos agrupaciones claras de arrays <code>derecha e izquierda'' y</code>arriba y abajo’’ de la figura. El hecho de que los grupos no se correspondan con los tratamientos sugiere que puede haber alguna fuente adicional de variación que ha de tenerse en cuenta.</p>

</div>
<div id="imagen-del-chip" class="section level4">
<h4><span class="header-section-number">3.2.1.4</span> Imagen del chip</h4>
<p>Otra forma de ver si las muestras se agrupan según los grupos experimentales, o mediante otros criterios es usando un cluster jerárquico que realiza una agrupación básica de las muestras por grado de similaridad según la distancia que se utilice.</p>
<p>Como en el caso de las componentes principales si las muestras se agrupan según las condiciones experimentales es una buena señal pero si no es así puede deberse a la presencia de otra fuente de variación o bien al hecho de que se trata de un gráfico basado en todo los datos y las condiciones experimentales pueden haber afectado un pequeño número de genes.</p>
<p>La figura ~ muestra como se agrupan los datos del conjunto  en base a un cluster jerárquico. Como en el caso de las componentes principales tras eliminar el array defectuoso las muestras se separan, primero por el tiempo de exposición y luego por niveles de estrógeno suministrado.</p>

</div>
</div>
<div id="gráficos-de-diagnóstico-para-microarrays-de-dos-colores" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Gráficos de diagnóstico para microarrays de dos colores</h3>
<p>El diagnóstico de arrays de dos canales se basa principalmente
en la imagen y en diferentes tipos de gráficos.</p>
<div id="diagramas-de-dispersión-y-maplots" class="section level4">
<h4><span class="header-section-number">3.2.2.1</span> Diagramas de dispersión y ``MA–plots’’</h4>
<p>La normalización discutida en este mismo capítulo es un punto
clave en el proceso de análisis de microarrays y se ha dedicado un
gran esfuerzo a desarrollar y probar diferentes métodos
(~). Una razón para ello es que
hay diferentes artefactos técnicos que deben ser corregidos para
poder ser utilizados, y no cualquier método puede funcionar con
todos ellos.</p>
<p>En general, los métodos de normalización se basan en el siguiente
principio: .</p>
<p>Esto da una idea de como debería ser un gráfico de
intensidades. Por ejemplo, si no hubiese artefactos técnicos, en
arrays de dos canales, una gráfica de dispersión de intensidad del
rojo frente al verde debería dejar la mayor parte de los puntos
alrededor de una diagonal. Cualquier desviación de esta situación
debería ser atribuible a razones técnicas, no biológicas, y por
tanto, debería ser eliminada. Esto ha conducido a un método de
normalización muy popular consistente en estimar la transformación
a aplicar, como una función de las intensidades utilizando el
método  en la representación transformada de la
gráfica de dispersión conocida como el .</p>
<p>La figura ~ (a) muestra un gráfico de dispersión del canal
rojo frente al verde en un array de dos colores. El hecho de que los
datos no estén centrados alrededor de la diagonal sugiere la necesidad de
normalización.</p>
<p>Una representación muy popular que ayuda a visualizar mejor esta
asimetría es lo que se conoce como ``’’
((b)). Geométricamente representa una rotación del
gráfico de dispersión, en la que el significado de los nuevos ejes es:</p>


</div>
<div id="imagen-del-array" class="section level4">
<h4><span class="header-section-number">3.2.2.2</span> Imagen del array</h4>
<p>La imagen del chip (véase la figura ~,
izquierda) ofrece una visión rápida de la calidad del array,
proporcionando información acerca del balance del color, la
uniformidad en la hibridación y en los , de si el
background es mayor del normal y dela existencia de artefactos como el
polvo o pequeñas marcas (rasguños).</p>
</div>
<div id="histogramas-de-señales-y-de-la-relación-señalruído" class="section level4">
<h4><span class="header-section-number">3.2.2.3</span> Histogramas de señales y de la relación señal–ruído</h4>
<p>Estos gráficos (véase la figura ~, derecha) son útiles para detectar posibles anormalidades o un background excesivamente alto .</p>


</div>
<div id="boxplots" class="section level4">
<h4><span class="header-section-number">3.2.2.4</span> Boxplots</h4>
<p>Un gráfico muy utilizado es el diagrama de cajas o ``boxplot’’
múltiple con una caja por cada chip. Del alineamiento (o falta de
él) y la semejanza (o disparidad) entre las cajas, se deduce si hace
falta, o no, normalizar entre arrays.</p>
<p>En el caso de arrays de dos colores pueden utilizarse diagrams de
cajas <code>dentro de arrays'' (entre distintos sectores del mismo chip) y</code>entre arrays’’.</p>
</div>
</div>
<div id="gráficos-de-diagnóstico-para-microarrays-de-un-color" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Gráficos de diagnóstico para microarrays de un color</h3>
<div id="imagen-del-chip-1" class="section level4">
<h4><span class="header-section-number">3.2.3.1</span> Imagen del chip</h4>
<p>Los arrays de affymetrix contienen millones de sondas por lo que no pueden examinarse a simple vista. A pesar de ello hay diversas formas de obtener una imagen que, en caso de presentar irregularidades pueden indicar algún tipo de problemas como burbujas, arañazos, etc. La figura ~ muestra algunas de las imágenes</p>


</div>
<div id="gráfico-m-a" class="section level4">
<h4><span class="header-section-number">3.2.3.2</span> Gráfico ``M-A’’</h4>
<p>En los chips de dos colores el MA–plot se utliza para comparar los dos canales en cada array (rojo y verde). En cambio, en los chips de Affymetrics, en que sólo hay un canal en cada array, la única forma de definir M (el log ratio) es a partir de la comparación entre pares de de valores, ya sea los arrays dos a dos o bien cada array respecto un valor de referencia que puede ser la mediana, punto a punto, de todos los arrays (véase por ejemplo la figure ).</p>


<p><span class="math inline">\(M=\log_2(I_1) - \log_2(I_2)\)</span>: log ratio
<span class="math inline">\(A=\displaystyle \frac{1}{2}(\log_2 (I_1)+\log_2(I_2))\)</span>: log de intensidades
Donde <span class="math inline">\(I_1\)</span> es la intensidad del array de estudio, e <span class="math inline">\(I_2\)</span> es la intensidad media de arrays.
Por lo general, se espera que la distribución en el gráfico se concentre a lo largo del eje M = 0.</p>
</div>
<div id="gráficos-de-degradación" class="section level4">
<h4><span class="header-section-number">3.2.3.3</span> Gráficos de degradación</h4>
<p>La calidad de la hibridación del ARN a lo largo de los conjuntos de sondas puede variar. Si un grupo de arrays el nivel de degradación es desigual suele considerarse que su calidad es baja.</p>
<p>La figura ~ muestra los gráficos de degradación para el conjunto de datos  pudiendo observarse como, en este caso el array  no presenta un patrón de degradación distinto.</p>


</div>
<div id="modelos-de-bajo-nivel-probe-level-models-o-plm" class="section level4">
<h4><span class="header-section-number">3.2.3.4</span> Modelos de bajo nivel (``Probe-Level-Models’’ o PLM)</h4>
<p>Los modelos de bajo nivel (<code>Probe-Level-Models'' o PLM) ajustan a los valores de intensidad --a nivel de sondas, no de valores totalizados de gen-- un modelo explicativo. Los valores estimados por este modelo se comparan con los valores reales y se obtienen los errores o</code>residuos’’ del ajuste. El análisis de dichos residuos procede de forma similar a lo que se realiza al analizar un modelo de regresión:
Si los errores no presentan ningún patrón especial supondremos que el modelo se ajusta relativamente bien.
Si, en cambio, observamos desviaciones de esta presunta aleatoriedad querrá decir que el modelo no explica bien las observaciones, lo cual se atribuirá a la existencia de algún problema con los datos.</p>
<p>Con los valores ajustados del modelo se calculan dos medidas:</p>

<pre><code>## Loading required package: affyPLM</code></pre>
<pre><code>## Loading required package: gcrma</code></pre>
<pre><code>## Loading required package: preprocessCore</code></pre>
<p>La figura ~ muestra los gráficos RLE y NUSE para el conjunto de datos estrogen. En ambos gráficos puede verse como el array defectuoso ``’’ queda claramente diferenciado del resto.</p>


</div>
</div>
</div>
<div id="normalización-de-arrays-de-dos-colores" class="section level2">
<h2><span class="header-section-number">3.3</span> Normalización de arrays de dos colores</h2>
<p>La palabra  describe las técnicas utilizadas para transformar adecuadamente los datos antes de que sean analizados.
El objetivo es corregir diferencias sistemáticas entre muestras, en la misma o entre imágenes, lo que no representa
una verdadera variación entre las muestras biológicas.</p>
Estas diferencias sistemáticas pueden deberse, entre otras, a:

A veces puede ser difícil detectar estos problemas , aunque existen algunas formas de saber si es necesaria realizar una normalización. Aqui destacamos dos posibilidades:

<div id="normalización-global" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Normalización global</h3>
<p>Este método esta basado en un ajuste global, es decir en modificar todos los valores una cantidad , estimada de acuerdo a algún criterio.
<span class="math display">\[\begin{equation}
 \log_2 R/G \rightarrow \log_2 R/G-c=\log_2 R/(Gk)
\end{equation}\]</span>
opciones para <span class="math inline">\(k\)</span> o <span class="math inline">\(c= \log_2k\)</span> son</p>
<p><span class="math inline">\(c\)</span>= mediana o media de log ratio para un conjunto concreto de genes o genes control o genes housekeeping.</p>
<p>La intensidad total de la normalización</p>
<p><span class="math inline">\(k=\sum R_i/\sum G_i\)</span>
%imagen ejemplo de Callow</p>
</div>
<div id="normalización-dependiente-de-la-intensidad" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Normalización dependiente de la intensidad</h3>
<p>En este caso se realiza una modificación específica para cada valor. Esta modificación se obtiene como una función de la intensidad total del gen (<span class="math inline">\(c=c(A)\)</span>).
<span class="math display">\[\begin{equation}
 \log_2 R/G \rightarrow \log_2 R/G-c(A)=\log_2 R/(Gk(A))
\end{equation}\]</span></p>
<p>Una posible estimación de esta función puede hacerse utilizando la función  (LOcally WEighted Scatterplot Smoothing).</p>
</div>
</div>
<div id="resumen-y-normalización-de-microarrays-de-affymetrix" class="section level2">
<h2><span class="header-section-number">3.4</span> Resumen y normalización de microarrays de Affymetrix</h2>
<p>En los arrays de Affymetrix, como en todos los tipos de microarrays, tras escanear la imagen se obtiene una serie de valores de
intensidad de cada elemento del chip.
En el caso de estos arrays sabemos que cada valor no corresponde a la expresión de un gen:</p>

El proceso que convierte las señales individuales en valores de expresión normalizados para cada gen consta de tres etapas:

<p>A menudo los tres pasos se denominan genérica -y erróneamente- ’’normalización``.</p>
<p>A diferencia de los chips de ADNc, aquí las medidas de expresión son absolutas (no se compara una condición contra otra)
dado que cada chip se hibrida con un única muestra.</p>
<p>Hay muchos métodos para estimar la expresión (más de 30 publicados).
Cada método contempla de forma explícita o implícita las tres formas de preprocesado: corrección del fondo,
normalización y resumen.</p>
Los principales métodos que consideraremos son:

<div id="métodos-originales-de-affymetrix" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Métodos originales de Affymetrix</h3>
<div id="m.a.s.-4.0" class="section level4">
<h4><span class="header-section-number">3.4.1.1</span> M.A.S. 4.0</h4>
Es el primer método introducida por Affymetrix.
La corrección del fondo se realiza restando el ’’perfect match<code>del ''mismatch</code>
<span class="math display">\[\begin{equation}
 E_j=PM_j-MM_j
\end{equation}\]</span>
La normalización se realiza de forma global haciendo transformaciones de forma que la media de todo el chip sea la misma y
la sumarización se basa en calcular el promedio de las diferencias absolutas ignorando los pares que se desvían más de <span class="math inline">\(3\sigma\)</span> de <span class="math inline">\(\mu\)</span>.
<span class="math display">\[\begin{equation}
 Dif. Media=\frac{1}{|A|}\sum_{j \in A}(PM_j-MM_j)
\end{equation}\]</span>
Los problemas que presenta estemétodo son:

</div>
<div id="m.a.s.-5.0" class="section level4">
<h4><span class="header-section-number">3.4.1.2</span> M.A.S. 5.0</h4>
<p>Los problemas que presentaba el método M.A.S. 4.0 llevaron a
sustituirlo por otra variante, el M.A.S 5.0, llamado así por venir
implementado en el software de affymetrix llamado ’’MicroArray Suite
5.0``.</p>
<p>Este método utiliza un estadístico robusto, , para corregir y ponderar el fondo y calcular (estimar) la
señal. El biweight de Tukey <span class="math inline">\(T_{bi}\)</span> pondera los valores por su
distancia a la mediana, es decir, mide la tendencia central pero
realiza un ajuste de outliers.</p>
La lógica de este método reside en pensar que el valor de MM no siempre tiene sentido, (p.ej si MM <span class="math inline">\(&gt;\)</span> PM).
Dado que esto sucede en ocasiones se realiza el cambio siguiente:

<p>Este método no tan solo corrige el background sino que también permite normalizar y sumarizar.
Para ello se introduce el ’’Mismatch Idealizado<code>(IM) que permite corregir la intensidad de las pruebas individuales. Este método también ha sido muy criticado: \begin{itemize} \item Se considera que no tiene mucho sentido promediar las pruebas entre arrays, pues éstos pueden tener características de hibridación intrínsecamente distintas. \item El método no mejora ''aprendiendo</code> del funcionamiento entre arrays de las pruebas individuales.
\end{itemize}</p>
</div>
</div>
<div id="el-método-rma-robust-multi-array-average" class="section level3">
<h3><span class="header-section-number">3.4.2</span> El método RMA (Robust Multi-Array Average)</h3>
<p>Para compensar algunas deficiencias de los primeros métodos de
resumen y normalización de arrays de Affymetrix, Irizarry y sus
colegas introdujeron en 2003 (~) un método basado en la modelización de las intensidades de las sondas que, en vez de basarse en las distintas sondas de un gen dentro de un mismo array se basa en los distintos valores de la misma sonda entre todos los arrays disponibles,</p>
Esquemáticamente los pasos que realiza este método son:

<p>Como resultado final de todos los pasos anteriores se obtiene la matriz con los datos sumarizados y normalizados. A pesar de no estar exento de críticas como la que afirma que este procedimiento<code>compacta'' los valores reduciendo su variabilidad natural, este método se ha convertido en el estándar ''de facto</code> actualmente por muchos usuarios de Bioconductor.</p>


<p>\begin{figure}[!h]


</p>
El filtraje no específico es recomendable para eliminar el ruido de fondo y limitar los ajustes posteriores a los necesarios.
Los principales procesos de filtrado son:

<p>El objetivo del filtraje es eliminar aquellos spots cuyas imágenes o señales sean erróneas por diferentes motivos, disminuyendo el ruido
de fondo. Aunque existe controversia a su uso, prefiriendo el no filtrado a eliminar de forma no intencionado spots informativos.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="el-proceso-de-análisis-de-microarrays.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="referencias.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
